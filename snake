.equ HEAD_X, 0x1000 ; snake head's position on x-axis
.equ HEAD_Y, 0x1004 ; snake head's position on y-axis
.equ TAIL_X, 0x1008 ; snake tail's position on x-axis
.equ TAIL_Y, 0x100C ; snake tail's position on y-axis
.equ SCORE, 0x1010 ; score address
.equ GSA, 0x1014 ; game state array
.equ LEDS, 0x2000 ; LED addresses
.equ SEVEN_SEGS, 0x1198 ; 7-segment display addresses
.equ RANDOM_NUM, 0x2010 ; Random number generator address
.equ BUTTONS, 0x2030 ; Button addresses

; BEGIN:clear_leds
clear_leds:

ldw t0, LEDS(zero)		; Load the current value of LEDS[0]
ldw t1, LEDS+4(zero)	; Load the current value of LEDS[1]
ldw t2, LEDS+8(zero) 	; Load the current value of LEDS[2]
	
and t0, t0, zero		; LED[0] = 0x"0000"
and t1, t1, zero		; LED[1] = 0x"0000"
and t2, t2, zero		; LED[2] = 0x"0000"

stw t0, LEDS(zero)		; Storing the results in LEDS[0]
stw t1, LEDS+4(zero)	; Storing the results in LEDS[1]
stw t2, LEDS+8(zero)	; Storing the results in LEDS[2]

ret
; END:clean_data


;BEGIN: set_pixel
set_pixel:

addi a0, zero, 4		; this simulates the x input
addi a1, zero, 1		; this simulates the y input

addi t1, zero, 1
addi t2, zero, 2
addi t3, zero, 3

cmplti t0, a0, 4		; Compares the x value is less than 4
bne zero, t0, led0		; if it is true that means we're in LED[0]
cmplti t0, a0, 8		; otherwise we could be in LED[1] or LED[2]
bne zero, t0, led1		; Compares the x value is less than 8
cmplti t0, a0, 12		; otherwise we could be in LED[2]
bne zero, t0, led2

led0:

ldw t4, LEDS(zero)		; Upload the current state of the LEDS[0]

beq a0, zero, led0_0	; Compares: x=0
beq a0, t1, led0_1		; Compares: x=1
beq a0, t2, led0_2		; Compares: x=2
beq a0, t3, led0_3		; Compares: x=3

ret

led0_0:					; We enter here if we want to modify bits[7:0]
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS(zero)
ret

led0_1:					; We enter here if we want to modify bits[15:8]
addi a1, a1, 8			; We add 8 in order to select the second group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS(zero)
ret

led0_2:					; We enter here if we want to modify bits[23:16]
addi a1, a1, 16			; We add 8 in order to select the third group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1
stw t4, LEDS(zero)
ret

led0_3:					; We enter here if we want to modify bits[31:24]
addi a1, a1, 24			; We add 8 in order to select the fourth group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS(zero)
ret



led1:

ldw t4, LEDS+4(zero)	; Upload the current state of the LEDS[1]

sub a0, a0, t1
sub a0, a0, t3			; Substract a0-4 to have a value 0<x<4

beq a0, zero, led1_0	; Compares: x=0
beq a0, t1, led1_1		; Compares: x=1
beq a0, t2, led1_2		; Compares: x=2
beq a0, t3, led1_3		; Compares: x=3

ret


led1_0:					; We enter here if we want to modify bits[7:0]
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS+4(zero)
ret

led1_1:					; We enter here if we want to modify bits[15:8]
addi a1, a1, 8			; We add 8 in order to select the second group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS+4(zero)
ret

led1_2:					; We enter here if we want to modify bits[23:16]
addi a1, a1, 16			; We add 8 in order to select the third group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1
stw t4, LEDS+4(zero)
ret

led1_3:					; We enter here if we want to modify bits[31:24]
addi a1, a1, 24			; We add 8 in order to select the fourth group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS+4(zero)
ret



led2:
ldw t1, LEDS+8(zero)

sub a0, a0, t2
sub a0, a0, t3
sub a0, a0, t3			; Substract a0-8 to have a value 0<x<4

beq a0, zero, led2_0	; Compares: x=0
beq a0, t1, led2_1		; Compares: x=1
beq a0, t2, led2_2		; Compares: x=2
beq a0, t3, led2_3		; Compares: x=3

ret 

led2_0:					; We enter here if we want to modify bits[7:0]
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS+8(zero)
ret

led2_1:					; We enter here if we want to modify bits[15:8]
addi a1, a1, 8			; We add 8 in order to select the second group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS+8(zero)
ret

led2_2:					; We enter here if we want to modify bits[23:16]
addi a1, a1, 16			; We add 8 in order to select the third group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1
stw t4, LEDS+8(zero)
ret

led2_3:					; We enter here if we want to modify bits[31:24]
addi a1, a1, 24			; We add 8 in order to select the fourth group of bits
sll t1, t1, a1			; Shift left "y" times
or t4, t4, t1 
stw t4, LEDS+8(zero)
ret

; BEGIN: get_input
get_input:
	
	ldw t0, BUTTONS(zero)
	ldw t1, BUTTONS+4(zero)

	addi t5, t5, 31
	bne t0, t5, update
	
	ret
; END: get_input

; BEGIN: update
update:

	ldw t2, HEAD_X(zero)
	ldw t3, HEAD_Y(zero)
	
	slli t2, t2, 5			; 32x
	slli t3, t3, 2			; 4y
	add t4, t2, t3			; 32x + 4y
	addi t4, t4, GSA		; Final head GSA address: GSA base address + 32x +4y
	
	andi t1, t1, 15			; ignore bit 5
		
	stw t1,  0(t4)			; update the content
	and t1, t1, zero		; clear edge capture
	stw t0, BUTTONS+4(zero)
	
	ret
; END: update

; BEGIN:move_snake
move_snake:
	
	;----------------- HEAD Handling ---------------------

	ldw t0, HEAD_X(zero)	; loading x cood of head
	ldw t1, HEAD_Y(zero)	; loading y cood of head
	
							; retreive GSA of head
	
	slli t2, t0, 5			; 32X
	slli t3, t1, 2			; 4Y

	add t4, t2, t3			; store 32X + 4Y
	addi t5, t4, GSA		; t5 contains the GSA address of the head

	ldw	t6, 0(t5)			; load in t6 the content of the head's GSA

	call updateX			; updateX
	call updateY			; updateY

	; At this moment, t0 and t1 contain the new values for x and y respectively and t6 still holds the old GSA's content

	stw t0, HEAD_X(zero)	; put the new X value in HEAD_X
	stw t1, HEAD_Y(zero)	; put the new Y value in HEAD_Y

	; Now we calculate the new head's GSA address
 
	slli t2, t0, 5			; 32X
	slli t3, t1, 2			; 4Y

	add t4, t2, t3			; store 32X + 4Y
	addi t5, t4, GSA		; t5 contains the GSA address of the new head
	
	stw t6, 0(t5)			; store  the old GSA content(t6) in the new GSA address(t5)



	;----------------- TAIL Handling ---------------------


	addi t2, zero, 1		; we store in t2 the value 1
	beq a0, t2, endMoveSnake; if a0 = 1 then we directly return

	ldw t0, TAIL_X(zero)	; loading x cood of tail
	ldw t1, TAIL_Y(zero)	; loading y cood of tail

							; retreive GSA of tail
	
	slli t2, t0, 5			; 32X
	slli t3, t1, 2			; 4Y

	add t4, t2, t3			; store 32X + 4Y
	addi t5, t4, GSA		; t5 contains the GSA address of the tail

	ldw	t6, 0(t5)			; load in t6 the content of the tail's GSA

	call updateX			; updateX
	call updateY			; updateY

	; At this moment, t0 and t1 contain the new values for x and y respectively and t6 still holds the old GSA's content
	; and t5 still holds the ol GSA content
	
	stw t0, TAIL_X(zero)		; put the new X value in HEAD_X
	stw t1, TAIL_Y(zero)		; put the new Y value in HEAD_Y

	; Now we calculate the new tail's GSA address
 
	slli t2, t0, 5			; 32X
	slli t3, t1, 2			; 4Y

	add t4, t2, t3			; store 32X + 4Y
	addi t7, t4, GSA		; t7 contains the GSA address of the new tail
	
	stw t6, 0(t7)			; store the old GSA content(t6) in the new GSA address(t7)
	stw zero, 0(t5)				; store 0 ath the old GSA address t5 (i.e turn it off)

endMoveSnake: ret



	;---------------- Auxilliary functions ---------------------


updateX:

	addi t2, zero, 1		; stock in t2 the value 1
	beq t6, t2, decX		; if head's GSA is 1, decrement X
	addi t2, zero, 4		; stock in t2 the value 4
	beq t6, t2, incX		; if head's GSA is 4, increment X
ret

decX:
	addi t0, t0, -1			; decrement X value in t0 by 1
ret

incX:
	addi t0, t0, 1			; increment X value in t0 by 1
ret


updateY:

	addi t2, zero, 2		; stock in t2 the value 2
	beq t6, t2, decY		; if head's GSA is 2, decrement Y
	addi t2, zero, 3		; stock in t2 the value 3
	beq t6, t2, incY		; if head's GSA is 3, increment Y
ret	

decY:
	addi t1, t1, -1			; decrement Y value in t1 by 1
ret

incY:
	addi t1, t1, 1			; increment Y value in t1 by 1
ret


; END:move_snake



; BEGIN:draw_array
draw_array:

	;--------------------- Main loop ------------------------

	addi sp, zero, LEDS 	; initialize the stack pointer
	addi t0, zero, GSA		; initialize t0 as a counter to iterate through all GSAs
	addi t1, zero, SEVEN_SEGS ; put in t1 the stop address 
	
; SEVEN_SEGS is the value at which we want to stop iterating through the GSAs, iterating is done by steps of size 4

loop:
	
	
	beq t0, t1, end_draw_array

	ldw t2, 0(t0)			; load in t2 the currently examined GSA
	
	call draw				; call draw, which will compare and eventually set a pixel 
	
	addi t0, t0, 4			; increment t0, i.e progress through the GSAs
	br loop					; keep looping

end_draw_array: ret	


	;---------------- Auxilliary functions ---------------------

draw:
	
	beq t2, zero, endDraw	; if pixel should be turned off, terminate
	
; PUSH operation on stack
	addi sp, sp, -4			; decrement stack pointer		
	stw ra, 0(sp)			; store previous ra value in stack due to incoming nested call
	
	call cood

	add a0, zero, t3		; put in a0 the newly found xCood in preparation of set pixel
	add a1, zero, t4		; put in a0 the newly found xCood in preparation of set pixel	
	
	call set_pixel

; POP operation on stack
	ldw ra, 0(sp)			; load in ra the appropriate return address
	addi sp, sp, 4			; increment stack pointer
	
endDraw: ret

; function cood finds the values of x and y from the GSA address (in t0)
cood:

	addi t3, zero, 0		; t3 will contain x coordinate, initialize to 0
	addi t4, zero, 0		; t4 will contain y coordinate, initialize to 0
	addi t5, t0, 0			; t5 will contain the GSA address that we'll modify to find out x and y, preserving t0 
	addi t6, zero, GSA		; t6 will be used to compare value to GSA (because it's not a register)

; PUSH operation on stack
	addi sp, sp, -4			; decrement stack pointer		
	stw ra, 0(sp)			; store previous ra value in stack due to incoming nested call

	call Xloop
	call Yloop

; POP operation on stack
	ldw ra, 0(sp)			; load in ra the appropriate return address
	addi sp, sp, 4			; increment stack pointer

ret


Xloop:
	
	blt t5, t6, adj_exitX	; if we've passed the GSA value, we have our xCood
	addi t5, t5, -32		; decrement GSA by a step (size 32)
	addi t3, t3, 1			; increment xCood
	br Xloop				; keep looping	

adj_exitX:

	addi t3, t3, -1			; adjust xCood
	addi t5, t5, 32			; adjust t5 for incoming Yloop
	br endXloop				; terminate
	

endXloop: ret

Yloop:
	
	blt t5, t6, adj_exitY	; if we've passed the GSA value, we have our xCood
	addi t5, t5, -4			; decrement GSA by a step (size 4)
	addi t4, t4, 1			; increment yCood
	br Yloop				; keep looping	

adj_exitY:

	addi t4, t4, -1			; adjust yCood
	br endYloop				; terminate
	
endYloop: ret
; END:draw_array
